一 pytorch模板
(1) torch.backends.cudnn.benchmark = true
设置这个 flag 可以让内置的 cuDNN 的 auto-tuner 自动寻找最适合当前配置的高效算法，来达到优化运行效率的问题,放在代码前面。
遵循以下准则：
    1.如果网络的输入数据维度或类型上变化不大，设置 torch.backends.cudnn.benchmark = true 可以增加运行效率；
    2.如果网络的输入数据在每次 iteration 都变化的话，会导致 cnDNN 每次都会去寻找一遍最优配置，这样反而会降低运行效率

(2)
nn.parallelss.data_parallel(module, inputs, device_ids=None, output_device=None, dim=0, module_kwargs=None)
model = torch.nn.DataParallel(module, device_ids=None, output_device=None, dim=0)

(3)
>>>torch.Tensor(4).fill_(10)
10
10
10
10
[torch.FloatTensor of size 4]

(4)PSNR: 峰值信噪比

def PSNR(img1, img2):
	mse = np.mean( (img1/255. - img2/255.) ** 2 )
	if mse == 0:
		return 100
	PIXEL_MAX = 1
	return 20 * math.log10(PIXEL_MAX / math.sqrt(mse))
SSIM:



(5)python:set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。
   x.mul(y) ，点乘操作
   x.mm(y) ，矩阵相乘， 矩阵大小需满足： (i, n)x(n, j)

getattr(object, name[, default]):从对象object中获取名称为name的属性，等效与调用object.name

#定义类Student
>>> class Student:
    def __init__(self,name):
        self.name = name

        
>>> s = Stduent('Aim')
>>> getattr(s,'name') #等效于调用s.name
'Aim'
>>> s.name
'Aim'

函数第三个参数default为可选参数，如果object中含义name属性，则返回name属性的值，如果没有name属性，则返回default值，如果default未传入值，则报错
>>> getattr(s,'name') #存在属性name
'Aim'

>>> getattr(s,'age',6) #不存在属性age，但提供了默认值，返回默认值
6

>>> getattr(s,'age') #不存在属性age，未提供默认值，调用报错
Traceback (most recent call last):
  File "<pyshell#17>", line 1, in <module>
    getattr(s,'age')
AttributeError: 'Stduent' object has no attribute 'age'

(6)python随机函数（import random)
random.uniform(a,b)：生成一个[a,b]范围内的随机浮点数(允许a>=b)
random.randint(a,b)：生成一个[a,b]范围内的整数
random.random():生成一个0到1的随机浮点数
random.choice(sequence)：从序列sequence中随机选取一个元素
>>> for i in range(5):
>>>     print(random.randint(0, 9),random.uniform(0, 9), random.random(), random.choice('hellow'), random.choice([1, 2, 3]))
8 3.6717202992809166 0.4450690594361921 o 2
7 0.291524162935034 0.2877539670863245 h 2
7 7.990317605967447 0.22999885193608072 w 2
3 4.247655650239005 0.07462456472771684 w 2
8 1.8543564978721014 0.7459599018055564 e 1

random.shuffle()：将一个列表中的元素打乱
>>> for i in range(5):
>>>     p = ['a', 'little', 'happy', 'pig']
>>>     random.shuffle(p)
>>>     print(p)
['little', 'a', 'happy', 'pig']
['a', 'pig', 'little', 'happy']
['pig', 'little', 'happy', 'a']
['little', 'happy', 'a', 'pig']
['a', 'little', 'pig', 'happy']

random.sample(sequence,k)：从序列sequence中随机获取长度为k的片段，不会改变原有序列
>>> for i in range(5):
>>>     p = ['a', 'little', 'happy', 'pig']
>>>     a = random.sample(p, 3)
>>>     print(p, a)
['a', 'little', 'happy', 'pig'] ['a', 'happy', 'pig']
['a', 'little', 'happy', 'pig'] ['little', 'happy', 'a']
['a', 'little', 'happy', 'pig'] ['a', 'happy', 'little']
['a', 'little', 'happy', 'pig'] ['happy', 'little', 'a']
['a', 'little', 'happy', 'pig'] ['little', 'a', 'happy']

random.randrange(a, b, c)：生成从a到b的间隔为c的随机整数
random.randrange(1,100,2)相当于random.choice(range(1,100,2))

(7)python生成随机矩阵
import numpy as np
np.random.uniform(a, b, [size_x, size_y]) 生成[a, b)范围内的随机浮点矩阵，服从均匀分布
np.random.randint(a, b, [size_x, size_y]) 生成[a, b)范围内的随机整数矩阵，服从均匀分布
np.random.randn(size_x, size_y) 生成标准正态分布矩阵
np.random.rand(size_x, size_y) 生成0-1均匀分布矩阵

(8)CycleGan与Pix2PixHD 报错处理
技术原创网址：https://blog.csdn.net/mxs30443/article/details/79793933
CycleGan的pytorch代码使用了python的visdom的可视化模块，但是在画图的时候回报错误：

    requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=8097): Max retries exceeded with url: /events (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7f19f9a5f0f0>: Failed to establish a new connection: [Errno 111] Connection refused',))

解决方案：
1、首先在控制台下启动visdom：

    python -m visdom.server

会看到输出：

        Downloading scripts. It might take a while.
        It's Alive!
        INFO:root:Application Started
        You can navigate to http://localhost:8097

不要关闭这个窗口
2、打开浏览器：

输入网址 http://localhost:8097 就会看到visdom界面
不要关闭这个界面
3、然后再运行CycleGan的代码就会看到在浏览器的界面上过会有图像显示,(这时可以关闭浏览器了，但是保持第一步的控制台处于打开状态)

(8)pytorch 加载模型报错Missing key(s) in state_dict，Unexpected key(s) in state_dict：
查看加载的模型参数结构：
state_dict = torch.load('./checkpoints/model.pth')
for k，v in state_dict.items():
    print(k, v)
解决方式：
a.如果保存的模型使用了torch.nn.DataParallel()，则加载模型也要用torch.nn.DataParallel()：
model = torch.nn.DataParallel(model)
torch.backends.cudnn.benchmark = True
b.创建一个没有‘module.’的新字典:
法1
state_dict = torch.load('model.pth')
from collections import OrderedDict
new_state_dict = OrderedDict()
for k, V in state_dict.items():
    name = k[7:] # remove 'module.'
	new_state_dict[name] = V
model.load_state_dict(new_state_dict)
法2
model.load_state_dict({k.replace('module.', ''):V for k,v in torch.load('model.pth').items()})

二 tensorflow 模板

(5)
tf.image.decode_image(tf.read_file(tf.string_join(['./training_set/', self.data_queue[0]])),channels=3)

tf.cast(img, tf.float32)

tf.image.rgb_to_grayscale(img)

tf.unstack(tf.random_crop(tf.stack(imgs, axis=0), [2, self.crop_size, self.crop_size, self.chns]), axis=0)

tf.convert_to_tensor(self.data_list, dtype=tf.string)

self.data_queue = tf.train.slice_input_producer([in_list, gt_list], capacity=20)

batch_in, batch_gt = tf.train.batch([image_in, image_gt], batch_size=batch_size, num_threads=8, capacity=20)


(7)hasattr(object, 'name')
判断一个对象里面是否有name属性或者name方法

(8)torch.clamp(input, min, max, out=None) → Tensor



